---
title: 31. 下一个排列
date: 2018-11-20 08:59:42
tags: [数组, 中等]
---

若没有头绪，尝试使用大量的极端 case 和一般 case 去发现隐藏的规律。

<!-- more -->

### 题目描述

实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。必须**原地**修改，只允许使用额外常数空间。

输入位于左侧列，其相应输出位于右侧列，如：`1,2,3` → `1,3,2`;  `3,2,1` → `1,2,3`; `1,1,5` → `1,5,1`



### 思路与实现

这道题归档为中等难度，在于其中的规律不易发现。遇到这种无从下手的问题，应该用更一般的几个 case 去寻找其中的规律，比如数列：

```
1 2 7 4 3 1 // 2 是分割点
1 3 7 4 2 1 // 交换 2 和 3，保证前序列为升序最小序列
1 3 1 2 4 7 // 反转 7 4 2 1，保证后序列为降序最大序列
```

可得出一般规律：

- 数列中存在数 `N`，`N` 往前是升序，`N` 往后是降序。
- 升序部分是升序组合的最小序列 `[1, 2]`，降序部分是降序部分的最大序列 `[7, 4, 3, 1]`

下一个排列即是**让分割点前部分是下一个排列，后部分为最小序列。**实现：

```go
func nextPermutation(nums []int) {
	isDesc := true
	n := len(nums)
	for i := 0; i < n-1; i++ {
		if nums[i] < nums[i+1] {
			isDesc = false // 处理 nums 为降序的特殊 case
		}
	}
	if isDesc {
		reverse(nums)
		return
	}

	l := 0
	for i := n - 1; i > 0; i-- {
		if nums[i-1] < nums[i] {
			l = i - 1 // 找到 N
			break
		}
	}

	for i := n - 1; i > l; i-- {
		if nums[i] > nums[l] {
			nums[i], nums[l] = nums[l], nums[i] // 交换 N 与后部分向上最小数
			break
		}
	}

	reverse(nums[l+1:]) // 将后部分降序（最大序列）反转为升序（最小序列）
}

func reverse(nums []int) {
	for i, j := 0, len(nums)-1; i < j; i, j = i+1, j-1 {
		nums[i], nums[j] = nums[j], nums[i]
	}
}
```

执行耗时：**4 ms (100%)**



### 最佳实现

如上



### 总结

第一次看到这个题确实没啥思路，像这种情况需要自己找大量的极端 case，一般 case 来发现其中隐藏的规律，代码实现即可，上边的代码只是两个循环一个 `reverse`，关于规律的思考才是重点。