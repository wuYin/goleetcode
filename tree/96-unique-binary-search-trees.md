---
title: 96. 不同的二叉搜索树
date: 2018-11-26 09:03:54
tags: [树, 中等]
---

当大问题可分解为小问题求解时，动态规划找子问题的基准情形是关键。

<!-- more -->

### 题目描述

给定一个整数 *n*，求以 1 ... *n* 为节点组成的二叉搜索树有多少种？**示例:**

```
输入: 3，输出: 5
解释: 给定 n = 3, 一共有 5 种不同结构的二叉搜索树:
   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```



### 思路与实现

读题很容易发现规律：全部的二叉树是由每个值为根节点，比它小的值组成**左子树**，比它大的值组成**右子树**所叠加成的合集。不要一开始就迷失在大 case 中，要像斐波那契数列问题一样，找简单的基准 case：

 `n=0` 时为空树，也是 BST，可推出：

```go
dp[0] = 1
dp[1] = 1
dp[2] = dp[0]*dp[1]   // 左子节点为根
	+ dp[1]*dp[0] // 右子节点为根
dp[3] = dp[0]*dp[2]   // 1 号节点为根
	+ dp[1]*dp[1] // 2 号为根
	+ dp[2]*dp[0] // 3 号为根
// ...        
```

`dp` 相乘是因为一整棵 BST 是由不同的左子树和右子树共同组成的。可得：

```go
n = 1	// 1 种	// 节点本身即根节点
n = 2	// 1+1= 2 种
n = 3	// 1*2 + 1 + 2*1 = 5 种
n = 4	// 1*5 + 1*2 + 2*1 + 5*1 = 14 种
// ...
```

dp 将大问题化解为 `n=0` 和 `n=1` 的两种基准子问题。实现：

```go
func numTrees(n int) int {
	dp := make([]int, n+1)
	dp[0], dp[1] = 1, 1
	for i := 2; i <= n; i++ {
		for left := 0; left < i; left++ {
			dp[i] += dp[left] * dp[i-1-left] // 左子树数量 * 右子树数量
		}
	}
	return dp[n]
}
```

执行耗时：**0 ms (100%)**

双层循环会让 dp 数组从 `0, 1, 2, 3, ...` 一直累加求解，最终累加到 N



### 最佳实现

如上的动态规划。



### 总结

当大问题可化解为小的子问题来组合解决时，需要分析基准情形，尝试找出子问题求解的方法和规律，最后合并子问题的解即可求解大问题，这即是动态规划。